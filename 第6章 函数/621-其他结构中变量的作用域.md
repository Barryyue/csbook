##其他结构中变量的作用域

&emsp;&emsp;上一节的一个要点不是只与函数之间的变量作用域有关：变量的作用域包含定义它们的代码块和直接嵌套在其中的代码块。这一点也适用于其他代码块，例如分支和循环结构的代码块。考虑下面的代码：

```javascript
        int i;
        for (i = 0; i < 10; i++)
        {
            string text = "Line" + Convert.ToString(i);
            Console.WriteLine("{0}", text);
        }
        Console.WriteLine("Last text output in loop: {0}", text);
```

&emsp;&emsp;字符串变量 `text` 是 `for` 循环的局部变量，这段代码不能编译，因为在该循环外部调用的 `Console.WriteLine()` 试图使用该变量 `text`，但是在循环外部该变量会超出作用域。修改代码，如下所示：

```javascript
        int i;
        string text;
        for (i = 0; i < 10; i++)
        {
            text = "Line" + Convert.ToString(i);
            Console.WriteLine("{0}", text);
        }
        Console.WriteLine("Last text output in loop: {0}", text);  ❌
```

&emsp;&emsp;这段代码也会失败，原因是必须在使用变量前对其进行声明和初始化，但 `text` 只在 `for` 循环中初始化。由于没有在循环外进行初始化，赋给 `text` 的值在循环块退出时就丢失了。但可以进行如下修改：

```javascript
        int i;
        string text = "";

        for (i = 0; i < 10; i++)
        {
            text = "Line" + Convert.ToString(i);
            Console.WriteLine("{0}", text);
        }
        Console.WriteLine("Last text output in loop: {0}", text);
```


&emsp;&emsp;这次 `text` 是在循环外部初始化，可以访问它的值。

&emsp;&emsp;在循环中最后赋给 `text` 的值可以在循环外部访问。可以看出，这个主题的内容需要花一点时间来掌握。在前面的示例中，循环之前赋给 `text` 空字符串，而在循环之后的代码中，该 `text` 就不会是空字符串了，其原因可能一下子看不出来。

&emsp;&emsp;这种情况的解释涉及分配给 `text` 变量的内存空间，实际上任何变量











🔚