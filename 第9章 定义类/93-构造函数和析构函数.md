##构造函数和析构函数

&emsp;&emsp;在 C#中定义类时，常常不需要定义相关的构造函数和析构函数，因为在编写代码时，如果没有提供它们，编译器会自动添加它们。但是，如有必要，可以提供自己的构造函数和析构函数，以便初始化对象和清理对象。

&emsp;&emsp;使用下述语法可以把一个简单的构造函数添加到类中：

```javascript
        class MyClass
        {
            public MyClass()
            {
                // Constructor code.
            }
        }
```

&emsp;&emsp;这个构造函数与包含它的类同名，且没有参数（使其成为类的默认构造函数），这是一个公共函数，所以类的对象可以使用这个构造函数进行实例化（详见第 8 章）。

```javascript
        class MyClass
        {
            private MyClass()
            {
                // Constructor code.
            }
        }
```

&emsp;&emsp;最后，通过提供参数，也可以采用相同的方式给类添加非默认的构造函数，例如：

```javascript
        class MyClass
        {
            public MyClass()
            {
                // Default constructor code.
            }

            public MyClass(int myInt)
            {
                // Nondefault constuctor code (uses myInt).
            }
        }
```

&emsp;&emsp;可提供的构造函数的数量不受限制（当然不能耗尽内存，也不能有相同的参数集，所以 “几乎不受限制” 更合适）。

&emsp;&emsp;使用略微不同的语法来声明析构函数。在.NET 中使用的析构函数（由 System.Object 类提供）称为 `Finalize()`，但这不是我们用于声明析构函数的名称。使用下面的代码，而不是重写 `Finalize()`:

```javascript
        class MyClass
        {
            ~MyClass()
            {
                // Destructor body.
            }
        }
```
&emsp;&emsp;类的析构函数由带有 `～` 前缀的类名来声明（构造函数也使用类名声明）。当进行垃圾回收时，就执行析构函数中的代码，释放资源。在调用这个析构函数后，还将隐式地调用基类的析构函数，包括 System.Object 根类中的 `Finalize()` 调用。该技术可以让.NET Framework 确保调用 `Finalize()`，因为重写 `Finalize()` 是指基类调用需要显式地执行，这是具有潜在危险的（第 10 章 将详细讨论如何调用基类的方法）。

####构造函数的执行序列

&emsp;&emsp;如果在类的构造函数中执行多个任务，把这些代码放在一个地方是非常方便的，这与第 6 章论述的把代码放在函数中有相同的优势。使用一个方法就可以把代码放在一个地方（详见第 10 章），但 C#提供了一个更好的方式。任何构造函数都可以配置为在执行自己的代码前调用其他构造函数。

&emsp;&emsp;在讨论构造函数前，先看一下在默认情况下，创建类的实例时会发生什么情况。出了前面说过的便于把初始化代码集中起来之外，还要了解这些代码。在开发过程中，由于调用构造函数时出现错误，对象常常并没有按照预期的那样执行。发生构造函数调用错误常常是因为类继承结构中的某个基类没有正确实例化，或者没有正确地给基类构造函数提供信息。如果理解在对象生命周期的这个阶段发生事情，将更利于解决此类问题。

&emsp;&emsp;为了实例化派生的类，必须实例化它的基类。而要实例化这个基类，又必须实例化这个基类的基类，这样一直到实例化 System.Object(所有类的根)为止。结果是无论使用什么构造函数实例化一个类，总是首先调用 `System.Object.Object()`。

&emsp;&emsp;无论在派生类上使用什么构造函数（默认的构造函数或非默认的狗杂函数），除非明确指定，否则就使用基类的默认构造函数（稍后将介绍如何改变这个行为）。下面介绍一个简短示例，说明执行的顺序。考虑下面的对象层次结构：

```javascript
        public class MyBaseClass
        {
            public MyBaseClass()
            {
            }

            public MyBaseClass(int i)
            {
            }
        }

        public class MyDerivedClass : MyBaseClass
        {
            public MyDerivedClass()
            {
            }

            public MyDerivedClass(int i)
            {
            }

            public MyDerivedClass(int i, int j)
            {
            }
        }
```

&emsp;&emsp;如果以下面的方式实例化 `MyDerivedClass` :

```javascript
        MyDerivedClass myObj = new MyDerivedClass();
```













🔚