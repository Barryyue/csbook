##构造函数和析构函数

&emsp;&emsp;在 C#中定义类时，常常不需要定义相关的构造函数和析构函数，因为在编写代码时，如果没有提供它们，编译器会自动添加它们。但是，如有必要，可以提供自己的构造函数和析构函数，以便初始化对象和清理对象。

&emsp;&emsp;使用下述语法可以把一个简单的构造函数添加到类中：

```javascript
        class MyClass
        {
            public MyClass()
            {
                // Constructor code.
            }
        }
```

&emsp;&emsp;这个构造函数与包含它的类同名，且没有参数（使其成为类的默认构造函数），这是一个公共函数，所以类的对象可以使用这个构造函数进行实例化（详见第 8 章）。

```javascript
        class MyClass
        {
            private MyClass()
            {
                // Constructor code.
            }
        }
```

&emsp;&emsp;最后，通过提供参数，也可以采用相同的方式给类添加非默认的构造函数，例如：

```javascript
        class MyClass
        {
            public MyClass()
            {
                // Default constructor code.
            }

            public MyClass(int myInt)
            {
                // Nondefault constuctor code (uses myInt).
            }
        }
```

&emsp;&emsp;可提供的构造函数的数量不受限制（当然不能耗尽内存，也不能有相同的参数集，所以 “几乎不受限制” 更合适）。

&emsp;&emsp;使用略微不同的语法来声明析构函数。在.NET 中使用的析构函数（由 System.Object 类提供）称为 `Finalize()`，但这不是我们用于声明析构函数的名称。使用下面的代码，而不是重写 `Finalize()`:

```javascript
        class MyClass
        {
            ~MyClass()
            {
                // Destructor body.
            }
        }
```
&emsp;&emsp;类的析构函数由带有 `～` 前缀的类名来声明（构造函数也使用类名声明）。当进行垃圾回收时，就执行析构函数中的代码，释放资源。在调用这个析构函数后，还将隐式地调用基类的析构函数，包括 System.Object 根类中的 `Finalize()` 调用。该技术可以让.NET Framework 确保调用 `Finalize()`，因为重写 `Finalize()` 是指基类调用需要显式地执行，这是具有潜在危险的（第 10 章 将详细讨论如何调用基类的方法）。

####构造函数的执行序列

&emsp;&emsp;如果在类的构造函数中执行多个任务，把这些代码放在一个地方是非常方便的，这与第 6 章论述的把代码放在函数中有相同的优势。使用一个方法就可以把代码放在一个地方（详见第 10 章）


🔚