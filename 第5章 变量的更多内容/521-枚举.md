## 枚举

>&emsp;&emsp;本书迄今介绍的每种类型（除 `string` 外）都有明确的取值范围。诚然，有些类型（如 `double`）的取值范围非常大，可以看成是连续的，但它们仍是一个固定集合。最简单的示例是 `bool` 类型，它只能取两个值：`true` 或 `false`。

>&emsp;&emsp;有时希望变量取的是一个固定集合中的值。例如，让 `orientation` 类型可以存储 `north`、`south`、`east` 或 `west` 中的一个值。

>&emsp;&emsp;此时可以使用枚举类型。枚举可以完成这个 `orientation` 类型的任务：它们允许定义一个类型，其取值范围是用户提供的值的有限集合。所以，需要创建自己的枚举类型 `orientation`，它可以从上述 4 个值中提取一个值。

>&emsp;&emsp;注意有一个附加步骤--不是仅仅声明一个给定类型的变量，而是声明和描述一个用户定义的类型，再声明这个新类型的变量。

####定义枚举

&emsp;&emsp;可以用 **`enum`** 关键字来定义枚举，如下所示：

```javascript
        enum <typeName>
        {
            <value1>,
            <value2>,
            <value3>,
            ...
            <valueN>
        }
```

>&emsp;&emsp;接着声明这个新类型的变量：

```javascript
        <typeName> <varName>;
    并赋值：
        <varName> = <typeName>.<value>;
```


&emsp;&emsp;枚举使用一个基本类型来存储。枚举类型可取的每个值都存储为该基本类型的一个值，默认情况下该类型为 `int`。在枚举声明中添加类型，就可以指定其他基本类型：

```javascript
        enum <typeName> : <underlyingType>
        {
            <value1>,
            <value2>,
            <value3>,
            ...
            <valueN>
        }
```

&emsp;&emsp;枚举的基本类型可以是 `byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`long` 和 `ulong`。

&emsp;&emsp;默认情况下，每个值都会根据定义的顺序（从 0 开始），被自动赋予对应的基本类型值。这意味着 `<value1>` 的值是 0，`<value2>` 的值是 1，`<value3>` 的值是 2 等。可以重写这个赋值过程：使用 `=` 运算符，指定每个枚举的实际值：

```javascript
        enum <typeName> : <underlyingType>
        {
            <value1> = <actualVal1>,
            <value2> = <actualVal2>,
            <value3> = <actualVal3>,
            ...
            <valueN> = <actualValN>
        }
```

&emsp;&emsp;还可以使用一个值作为另一个枚举的基础值，为多个枚举指定相同的值：

```javascript
        enum <typeName> : <underlyingType>
        {
            <value1> = <actualVal1>,        
            <value2> = <value1>,
            <value3>,
            ...
            <valueN> = <actualValN>
        }
```

&emsp;&emsp;未赋值的任何值都会自动获得一个初始值，这里使用的值是从比上一个明确声明的值大于 1 开始的序列。例如，在上面的代码中，`<value3>` 的值是 `<value1> + 1`。

&emsp;&emsp;注意 ⚠️这可能会产生预料不到的问题，在一个定义（如 `<value2> = <value1>`）后指定的值可能与其他值相同。例如，在下面的代码中，`<value4>` 的值与 `<value2>` 相同。

```javascript
        enum <typeName> : <underlyingType>
        {
            <value1> = <actualVal1>,
            <value2>,
            <value3> = <value1>,
            <vaue4>,
            ...
            <valueN> = <actualValN>
        }
```

&emsp;&emsp;当然，如果这正是希望的结果，则代码就是正确的。还要注意，以循环方式赋值可能会产生错误，例如：

```javascript
        enum <typeName> : <underlyingType>
        {
            <value1> = <value2>,
            <value2> = <value1>,
        }
```


>下面看一个示例。其代码定义了一个枚举 `orientation`，然后演示了它的用法。




🔚