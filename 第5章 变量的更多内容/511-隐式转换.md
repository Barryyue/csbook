## 隐式转换

&emsp;&emsp;隐式转换不需要做任何工作，也不需要另外编写代码。考虑下面的代码：

```javascript
        var1 = var2;
```

&emsp;&emsp;如果 `var2` 的类型可以隐式地转换为 `var1` 的类型，这个赋值语句就涉及一个隐式转换。这两个变量的类型也可能相同，此时就不需要隐式转换。例如，`ushort` 和 `char` 的值是可以互换的，因为它们都可以存储 0～65535 之间的数字，在这两个类型之间可以进行隐式转换，如下面的代码所示：

```javascript
        ushort destinationVar;
        char sourceVar = 'a';
        destinationVar = sourceVar;
        Console.WrileLine("sourceVar val: {0}", sourceVar);
        Console.WriteLine("destinationVar val: {0}", destinationVar);
```

&emsp;&emsp;这里存储在 `sourceVar` 中的值放在 `destinationVar` 中。在用两个 `Console.WriteLine( )` 命令输出变量时，得到如下结果：

```javascript
        sourceVar val : a
        destinationVar val : 97
```

&emsp;&emsp;即使两个变量存储的信息相同，使用不同的类型解释它们时，方式也是不同的。

&emsp;&emsp;简单类型有许多隐式转换：`bool` 和 `string` 没有隐式转换，但数值类型有一些隐式转换。`表 5-1` 列出了编译器可以隐式执行的数值转换（记住，`char` 存储的是数值，所以 `char` 被当作一个数值类型）。

**`表5-1 隐式数值转换`**

| 类型 | 可以安全地转换为 |
|-|-|
| byte | short，ushort，int，uint，long，ulong，float，double，decimal |
| sbyte | short，int，long，float，double，decimal |
| short | int，long，float，double，decimal |
| ushort | int，uint，long，ulong，float，double，decimal |
| int | long，float，double，decimal |
| uint | long，ulong，float，double，decimal |
| long | float，double，decimal |
| ulong | float，double，decimal |
| float | double |
| char | ushort，int，uint，long，ulong，float，double，decimal |
























🔚