##继承

&emsp;&emsp;继承是 OOP 最重要的特性之一。任何类都可以从另一个类中继承，这就是说，这个类拥有它继承的类的所有成员。在 OOP 中，被继承（也称为派生）的类称为父类（也称为基类）。注意 ⚠️，C#中的对象仅能直接派生于一个基类，当然基类也可以有自己的基类。

&emsp;&emsp;继承性可以从一个较一般的基类扩展或创建更多的特定类。例如，考虑一个代表农场家畜的类。这个类名 `Animal`，拥有 `EatFood()` 或 `Breed()` 等方法，我们可以创建一个派生类 `Cow`，支持所有这些方法，它也有自己的方法，如 `Moo()` 和 `SupplyMilk()`。还可以创建另一个派生类 `Chicken`，该类有 `Cluck()` 和 `LayEgg()` 方法。

&emsp;&emsp;在 UML 中，用箭头表示继承，`如图 8-7 所示`。

![图 8-7](/assets/8-7.png)

>&emsp;&emsp;**为简洁起见，`图 8-7` 中省略了成员的返回类型。**

&emsp;&emsp;在继承一个基类时，成员的可访问性就成了一个重要的问题。派生类不能访问基类的私有成员，但可以访问其公共成员。不过，派生类和外部的代码都可以访问公共成员，而不能由外部的代码访问。

&emsp;&emsp;为了解决这个问题，C#提供了第三种可访问性：`protected`，只有派生类才能访问 `protected` 成员。对于外部代码来说，这个可访问性与私有成员一样：外部代码不能访问 `private` 成员和 `protected` 成员。

&emsp;&emsp;除了定义成员的保护级别外，我们还可以为成员定义其继承行为。基类的成员可以是虚拟的，也就是说，成员可以由继承它的类重写。派生类可以提供成员的另一种实现代码。这种代码不会删除原来的代码，仍可以在类中访问原来的代码，但外部代码不能访问它们。如果没有提供其他实现方式，通过派生类使用成员的外部代码就自动访问基类中成员的实现代码。


>&emsp;&emsp;**虚拟成员不能是私有成员，因为这样会自相矛盾--不能既要求派生类重写成员，又不让派生类访问该成员。**










🔚